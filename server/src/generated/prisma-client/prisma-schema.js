module.exports = {
        typeDefs: // Code generated by Prisma (prisma@1.34.10). DO NOT EDIT.
  // Please don't change this file manually but run `prisma generate` to update it.
  // For more information, please read the docs: https://www.prisma.io/docs/prisma-client/

/* GraphQL */ `type AggregateConnection {
  count: Int!
}

type AggregatePiece {
  count: Int!
}

type BatchPayload {
  count: Long!
}

type Connection {
  id: ID!
  index: Int!
  piece: Piece!
  male: Boolean!
  shift: Direction!
  inclination: Direction!
}

type ConnectionConnection {
  pageInfo: PageInfo!
  edges: [ConnectionEdge]!
  aggregate: AggregateConnection!
}

input ConnectionCreateInput {
  id: ID
  index: Int!
  piece: PieceCreateOneWithoutConnectionsInput!
  male: Boolean!
  shift: Direction!
  inclination: Direction!
}

input ConnectionCreateManyWithoutPieceInput {
  create: [ConnectionCreateWithoutPieceInput!]
  connect: [ConnectionWhereUniqueInput!]
}

input ConnectionCreateWithoutPieceInput {
  id: ID
  index: Int!
  male: Boolean!
  shift: Direction!
  inclination: Direction!
}

type ConnectionEdge {
  node: Connection!
  cursor: String!
}

enum ConnectionOrderByInput {
  id_ASC
  id_DESC
  index_ASC
  index_DESC
  male_ASC
  male_DESC
  shift_ASC
  shift_DESC
  inclination_ASC
  inclination_DESC
}

type ConnectionPreviousValues {
  id: ID!
  index: Int!
  male: Boolean!
  shift: Direction!
  inclination: Direction!
}

input ConnectionScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  index: Int
  index_not: Int
  index_in: [Int!]
  index_not_in: [Int!]
  index_lt: Int
  index_lte: Int
  index_gt: Int
  index_gte: Int
  male: Boolean
  male_not: Boolean
  shift: Direction
  shift_not: Direction
  shift_in: [Direction!]
  shift_not_in: [Direction!]
  inclination: Direction
  inclination_not: Direction
  inclination_in: [Direction!]
  inclination_not_in: [Direction!]
  AND: [ConnectionScalarWhereInput!]
  OR: [ConnectionScalarWhereInput!]
  NOT: [ConnectionScalarWhereInput!]
}

type ConnectionSubscriptionPayload {
  mutation: MutationType!
  node: Connection
  updatedFields: [String!]
  previousValues: ConnectionPreviousValues
}

input ConnectionSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: ConnectionWhereInput
  AND: [ConnectionSubscriptionWhereInput!]
  OR: [ConnectionSubscriptionWhereInput!]
  NOT: [ConnectionSubscriptionWhereInput!]
}

input ConnectionUpdateInput {
  index: Int
  piece: PieceUpdateOneRequiredWithoutConnectionsInput
  male: Boolean
  shift: Direction
  inclination: Direction
}

input ConnectionUpdateManyDataInput {
  index: Int
  male: Boolean
  shift: Direction
  inclination: Direction
}

input ConnectionUpdateManyMutationInput {
  index: Int
  male: Boolean
  shift: Direction
  inclination: Direction
}

input ConnectionUpdateManyWithoutPieceInput {
  create: [ConnectionCreateWithoutPieceInput!]
  delete: [ConnectionWhereUniqueInput!]
  connect: [ConnectionWhereUniqueInput!]
  set: [ConnectionWhereUniqueInput!]
  disconnect: [ConnectionWhereUniqueInput!]
  update: [ConnectionUpdateWithWhereUniqueWithoutPieceInput!]
  upsert: [ConnectionUpsertWithWhereUniqueWithoutPieceInput!]
  deleteMany: [ConnectionScalarWhereInput!]
  updateMany: [ConnectionUpdateManyWithWhereNestedInput!]
}

input ConnectionUpdateManyWithWhereNestedInput {
  where: ConnectionScalarWhereInput!
  data: ConnectionUpdateManyDataInput!
}

input ConnectionUpdateWithoutPieceDataInput {
  index: Int
  male: Boolean
  shift: Direction
  inclination: Direction
}

input ConnectionUpdateWithWhereUniqueWithoutPieceInput {
  where: ConnectionWhereUniqueInput!
  data: ConnectionUpdateWithoutPieceDataInput!
}

input ConnectionUpsertWithWhereUniqueWithoutPieceInput {
  where: ConnectionWhereUniqueInput!
  update: ConnectionUpdateWithoutPieceDataInput!
  create: ConnectionCreateWithoutPieceInput!
}

input ConnectionWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  index: Int
  index_not: Int
  index_in: [Int!]
  index_not_in: [Int!]
  index_lt: Int
  index_lte: Int
  index_gt: Int
  index_gte: Int
  piece: PieceWhereInput
  male: Boolean
  male_not: Boolean
  shift: Direction
  shift_not: Direction
  shift_in: [Direction!]
  shift_not_in: [Direction!]
  inclination: Direction
  inclination_not: Direction
  inclination_in: [Direction!]
  inclination_not_in: [Direction!]
  AND: [ConnectionWhereInput!]
  OR: [ConnectionWhereInput!]
  NOT: [ConnectionWhereInput!]
}

input ConnectionWhereUniqueInput {
  id: ID
}

enum Direction {
  LEFT
  CENTER
  RIGHT
}

scalar Long

type Mutation {
  createConnection(data: ConnectionCreateInput!): Connection!
  updateConnection(data: ConnectionUpdateInput!, where: ConnectionWhereUniqueInput!): Connection
  updateManyConnections(data: ConnectionUpdateManyMutationInput!, where: ConnectionWhereInput): BatchPayload!
  upsertConnection(where: ConnectionWhereUniqueInput!, create: ConnectionCreateInput!, update: ConnectionUpdateInput!): Connection!
  deleteConnection(where: ConnectionWhereUniqueInput!): Connection
  deleteManyConnections(where: ConnectionWhereInput): BatchPayload!
  createPiece(data: PieceCreateInput!): Piece!
  updatePiece(data: PieceUpdateInput!, where: PieceWhereUniqueInput!): Piece
  updateManyPieces(data: PieceUpdateManyMutationInput!, where: PieceWhereInput): BatchPayload!
  upsertPiece(where: PieceWhereUniqueInput!, create: PieceCreateInput!, update: PieceUpdateInput!): Piece!
  deletePiece(where: PieceWhereUniqueInput!): Piece
  deleteManyPieces(where: PieceWhereInput): BatchPayload!
}

enum MutationType {
  CREATED
  UPDATED
  DELETED
}

interface Node {
  id: ID!
}

type PageInfo {
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  startCursor: String
  endCursor: String
}

type Piece {
  id: ID!
  index: Int!
  placed: Boolean!
  connections(where: ConnectionWhereInput, orderBy: ConnectionOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Connection!]
}

type PieceConnection {
  pageInfo: PageInfo!
  edges: [PieceEdge]!
  aggregate: AggregatePiece!
}

input PieceCreateInput {
  id: ID
  index: Int!
  placed: Boolean
  connections: ConnectionCreateManyWithoutPieceInput
}

input PieceCreateOneWithoutConnectionsInput {
  create: PieceCreateWithoutConnectionsInput
  connect: PieceWhereUniqueInput
}

input PieceCreateWithoutConnectionsInput {
  id: ID
  index: Int!
  placed: Boolean
}

type PieceEdge {
  node: Piece!
  cursor: String!
}

enum PieceOrderByInput {
  id_ASC
  id_DESC
  index_ASC
  index_DESC
  placed_ASC
  placed_DESC
}

type PiecePreviousValues {
  id: ID!
  index: Int!
  placed: Boolean!
}

type PieceSubscriptionPayload {
  mutation: MutationType!
  node: Piece
  updatedFields: [String!]
  previousValues: PiecePreviousValues
}

input PieceSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: PieceWhereInput
  AND: [PieceSubscriptionWhereInput!]
  OR: [PieceSubscriptionWhereInput!]
  NOT: [PieceSubscriptionWhereInput!]
}

input PieceUpdateInput {
  index: Int
  placed: Boolean
  connections: ConnectionUpdateManyWithoutPieceInput
}

input PieceUpdateManyMutationInput {
  index: Int
  placed: Boolean
}

input PieceUpdateOneRequiredWithoutConnectionsInput {
  create: PieceCreateWithoutConnectionsInput
  update: PieceUpdateWithoutConnectionsDataInput
  upsert: PieceUpsertWithoutConnectionsInput
  connect: PieceWhereUniqueInput
}

input PieceUpdateWithoutConnectionsDataInput {
  index: Int
  placed: Boolean
}

input PieceUpsertWithoutConnectionsInput {
  update: PieceUpdateWithoutConnectionsDataInput!
  create: PieceCreateWithoutConnectionsInput!
}

input PieceWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  index: Int
  index_not: Int
  index_in: [Int!]
  index_not_in: [Int!]
  index_lt: Int
  index_lte: Int
  index_gt: Int
  index_gte: Int
  placed: Boolean
  placed_not: Boolean
  connections_every: ConnectionWhereInput
  connections_some: ConnectionWhereInput
  connections_none: ConnectionWhereInput
  AND: [PieceWhereInput!]
  OR: [PieceWhereInput!]
  NOT: [PieceWhereInput!]
}

input PieceWhereUniqueInput {
  id: ID
  index: Int
}

type Query {
  connection(where: ConnectionWhereUniqueInput!): Connection
  connections(where: ConnectionWhereInput, orderBy: ConnectionOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Connection]!
  connectionsConnection(where: ConnectionWhereInput, orderBy: ConnectionOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): ConnectionConnection!
  piece(where: PieceWhereUniqueInput!): Piece
  pieces(where: PieceWhereInput, orderBy: PieceOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Piece]!
  piecesConnection(where: PieceWhereInput, orderBy: PieceOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): PieceConnection!
  node(id: ID!): Node
}

type Subscription {
  connection(where: ConnectionSubscriptionWhereInput): ConnectionSubscriptionPayload
  piece(where: PieceSubscriptionWhereInput): PieceSubscriptionPayload
}
`
      }
    